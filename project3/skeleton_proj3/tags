!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	Makefile	/^CC = gcc$/;"	m
COMPILE_OPTION	Makefile	/^COMPILE_OPTION = -g$/;"	m
HASH_TABLE_SIZE	hash.c	12;"	d	file:
LEX	Makefile	/^LEX = flex$/;"	m
LINK_OPTION	Makefile	/^LINK_OPTION = -lfl$/;"	m
YACC	Makefile	/^YACC = bison$/;"	m
YACC_OPTION	Makefile	/^YACC_OPTION = -vd$/;"	m
_ARRAY	subc.h	25;"	d
_CHAR	subc.h	23;"	d
_CONST	subc.h	15;"	d
_EQ	subc.h	34;"	d
_EXP	subc.h	18;"	d
_FUNC	subc.h	16;"	d
_GT	subc.h	32;"	d
_GTE	subc.h	33;"	d
_INT	subc.h	22;"	d
_LT	subc.h	30;"	d
_LTE	subc.h	31;"	d
_NE	subc.h	35;"	d
_POINTER	subc.h	27;"	d
_STRING	subc.h	24;"	d
_STRUCT	subc.h	26;"	d
_TYPE	subc.h	17;"	d
_VAR	subc.h	14;"	d
_VOID	subc.h	21;"	d
__SUBC_H__	subc.h	8;"	d
a	open_test/array_op.c	/^int a;$/;"	v
a	open_test/array_op2.c	/^int a;$/;"	v
a	open_test/assign_op.c	/^int a;$/;"	v
a	open_test/func_op2.c	/^int a; \/* error *\/$/;"	v
a	open_test/func_op2.c	/^int a;$/;"	v
a	open_test/func_op2.c	/^struct st2{} a; \/* error *\/$/;"	v	typeref:struct:st2
a	open_test/func_op2.c	/^struct st3{int a;} *spf(int x){$/;"	m	struct:st3	file:
a	open_test/func_op2.c	/^void a(int x, int y){ \/* error redec *\/$/;"	f
a	open_test/func_op3.c	/^int a; \/* error *\/$/;"	v
a	open_test/func_op3.c	/^int a;$/;"	v
a	open_test/func_op3.c	/^struct st2{} a; \/* error *\/$/;"	v	typeref:struct:st2
a	open_test/func_op3.c	/^struct st3{int a;} *spf(){ $/;"	m	struct:st3	file:
a	open_test/func_op3.c	/^void a(){ \/* error redec *\/$/;"	f
a	open_test/str_op3.c	/^		int a;$/;"	m	struct:str::str_in	file:
a	open_test/var_def.c	/^int a;$/;"	v
a	open_test/var_op.c	/^char* a; \/* error redec *\/$/;"	v
a	open_test/var_op.c	/^int a;$/;"	v
a	open_test/var_op.c	/^int* a; \/* error redec *\/$/;"	v
a	open_test/var_op2.c	/^int a;$/;"	v
a	open_test/var_op3.c	/^int a;$/;"	v
a	open_test/var_op4.c	/^int a;$/;"	v
a	temp.c	/^int a;$/;"	v
a	temp.c	/^struct a{} b;$/;"	s	file:
a	temp.c	/^void a(int x){$/;"	f
b	open_test/func_op3.c	/^struct st3{int b;} spf(){ \/* error *\/$/;"	m	struct:st3	file:
b	open_test/str_op3.c	/^		int b;$/;"	m	struct:str::str_in	file:
b	open_test/var_op.c	/^int b; \/* ok *\/$/;"	v
b	temp.c	/^struct a{} b;$/;"	v	typeref:struct:a
c	open_test/func_op2.c	/^int c; \/* pass! *\/$/;"	v
c	open_test/func_op3.c	/^int c; \/* pass! *\/$/;"	v
c	open_test/str_op.c	/^		char *c;$/;"	m	struct:str2::str3	file:
c	open_test/str_op.c	/^	char *c;$/;"	m	struct:str2	file:
c	open_test/str_op.c	/^	char *c;$/;"	m	struct:str3	file:
c	open_test/str_op.c	/^	char c;$/;"	m	struct:str1	file:
c	open_test/str_op2.c	/^		char *c;$/;"	m	struct:str2::str3	file:
c	open_test/str_op2.c	/^	char *c;$/;"	m	struct:str2	file:
c	open_test/str_op2.c	/^	char *c;$/;"	m	struct:str3	file:
c	open_test/str_op2.c	/^	char c;$/;"	m	struct:str1	file:
char_value	subc.h	/^	char char_value;$/;"	m	struct:decl
chartype	subc.h	/^decl *chartype;$/;"	v
check_add_sub	check.c	/^int check_add_sub(decl* x, decl* y, decl* dest){$/;"	f
check_and_or	check.c	/^int check_and_or(decl* x, decl* y, decl* dest){$/;"	f
check_inc_dec	check.c	/^int check_inc_dec(decl* src, decl* dest){$/;"	f
check_is_array	check.c	/^int check_is_array(decl* x){$/;"	f
check_is_const	check.c	/^int check_is_const(decl* x){$/;"	f
check_is_const_var	check.c	/^int check_is_const_var(decl* x, int incl_expr){$/;"	f
check_is_declared	check.c	/^int check_is_declared(id* name, int for_current){$/;"	f
check_is_pointer	check.c	/^int check_is_pointer(decl* x){$/;"	f
check_is_proc	check.c	/^int check_is_proc(decl* f){$/;"	f
check_is_struct	check.c	/^int check_is_struct(decl* x){$/;"	f
check_is_struct_type	check.c	/^int check_is_struct_type(decl* x){$/;"	f
check_is_var	check.c	/^int check_is_var(decl* x, int incl_expr){$/;"	f
check_rel_equ	check.c	/^int check_rel_equ(decl* x, decl* y, decl* dest, int op){$/;"	f
check_type_compat	check.c	/^int check_type_compat(decl* x, decl* y){$/;"	f
copy	functions.c	/^decl* copy(decl* org){$/;"	f
copy_ste	functions.c	/^ste* copy_ste(ste* s){$/;"	f
data	hash.c	/^	id *data;$/;"	m	struct:nlist	file:
debugst	functions.c	/^void debugst(ste* st){$/;"	f
decl	subc.h	/^	struct decl *decl;$/;"	m	struct:ste	typeref:struct:ste::decl
decl	subc.h	/^typedef struct decl{$/;"	s
decl	subc.h	/^} decl;$/;"	t	typeref:struct:decl
declare	functions.c	/^void declare(id* name, decl* decl){$/;"	f
declare_struct_type	functions.c	/^void declare_struct_type(id* name, decl* decl){$/;"	f
declclass	subc.h	/^	int declclass;$/;"	m	struct:decl
elementvar	subc.h	/^	struct decl *elementvar; \/\/ ARRAY, pointer to VAR decl$/;"	m	struct:decl	typeref:struct:decl::decl
enter	hash.c	/^id *enter(int tokenType, char *name, int length) {$/;"	f
f	open_test/func_op2.c	/^void f(int x, int x){ \/* error redec *\/$/;"	f
fields	subc.h	/^	struct ste *fields; \/\/ STRUCT, pointer to field list$/;"	m	struct:decl	typeref:struct:decl::ste
filename	subc.h	/^char *filename;$/;"	v
find	functions.c	/^ste* find(id* name){$/;"	f
find_current_scope	functions.c	/^ste* find_current_scope(id* name){$/;"	f
find_field	functions.c	/^ste* find_field(ste* fields, id* name){$/;"	f
fint	open_test/return.c	/^int fint(int x){$/;"	f
formals	subc.h	/^	struct ste *formals; \/\/ arguments$/;"	m	struct:decl	typeref:struct:decl::ste
fpint	open_test/return.c	/^int *fpint(int x){$/;"	f
func	open_test/args.c	/^int func(){$/;"	f
func	open_test/return.c	/^int func(int x, int y){ \/* error *\/$/;"	f
func	open_test/return.c	/^void func(int x, int y){$/;"	f
func1	open_test/func_op.c	/^int func1(int a, char b) {$/;"	f
func1	open_test/func_op2.c	/^int func1(int a) {$/;"	f
func2	open_test/args.c	/^char* func2(int x){$/;"	f
func2	open_test/func_op.c	/^char func2(void) {$/;"	f
func2	open_test/func_op2.c	/^void func2(int *a, int *b) {$/;"	f
func2	open_test/return.c	/^int func2(){$/;"	f
func3	open_test/args.c	/^char func3(int x, int* y, char z){$/;"	f
func3	open_test/func_op.c	/^void func3(int *a, int b) {$/;"	f
func3	open_test/return.c	/^void func3(void){$/;"	f
func4	open_test/args.c	/^int func4(char* x){$/;"	f
g	open_test/func_op2.c	/^void g(int g){ \/* pass *\/$/;"	f
globaldef	subc.h	/^ste *globaldef;$/;"	v
hashTable	hash.c	/^static nlist *hashTable[HASH_TABLE_SIZE]; \/\/ initially NULL$/;"	v	file:
i	open_test/str_op.c	/^		int *i;$/;"	m	struct:str2::str3	file:
i	open_test/str_op.c	/^	int *i;$/;"	m	struct:str2	file:
i	open_test/str_op.c	/^	int *i;$/;"	m	struct:str3	file:
i	open_test/str_op.c	/^	int i;$/;"	m	struct:str1	file:
i	open_test/str_op2.c	/^		int *i;$/;"	m	struct:str2::str3	file:
i	open_test/str_op2.c	/^	int *i;$/;"	m	struct:str2	file:
i	open_test/str_op2.c	/^	int *i;$/;"	m	struct:str3	file:
i	open_test/str_op2.c	/^	int i;$/;"	m	struct:str1	file:
id	subc.h	/^typedef struct id {$/;"	s
id	subc.h	/^} id;$/;"	t	typeref:struct:id
int_value	subc.h	/^	int int_value;$/;"	m	struct:decl
inttype	subc.h	/^decl *inttype;$/;"	v
lextype	subc.h	/^      int lextype;$/;"	m	struct:id
lookup	hash.c	/^struct id *lookup(char *name) {$/;"	f
main	open_test/args.c	/^void main(){$/;"	f
main	open_test/array_op.c	/^int main() {$/;"	f
main	open_test/array_op2.c	/^int main() {$/;"	f
main	open_test/assign_op.c	/^int main() {$/;"	f
main	open_test/func_op.c	/^int main(void) {$/;"	f
main	open_test/func_op2.c	/^int main(void) {$/;"	f
main	open_test/func_op3.c	/^int main(void) {$/;"	f
main	open_test/ptr_op.c	/^int main(void) {$/;"	f
main	open_test/str_op.c	/^int main(void) {$/;"	f
main	open_test/str_op2.c	/^int main(void) {$/;"	f
main	open_test/str_op3.c	/^void main(){$/;"	f
main	open_test/str_op4.c	/^void main(){$/;"	f
main	open_test/var_def.c	/^int main() {$/;"	f
main	open_test/var_op.c	/^int main() {$/;"	f
main	open_test/var_op2.c	/^int main() {$/;"	f
main	open_test/var_op3.c	/^int main() {$/;"	f
main	open_test/var_op4.c	/^int main() {$/;"	f
main	test.c	/^void main(){$/;"	f
makearraydecl	functions.c	/^decl* makearraydecl(int size, decl* var_decl){$/;"	f
makeconstdecl	functions.c	/^decl* makeconstdecl(decl* type_decl){$/;"	f
makeprocdecl	functions.c	/^decl* makeprocdecl(){$/;"	f
makeptrdecl	functions.c	/^decl* makeptrdecl(decl* type_decl){$/;"	f
makestructdecl	functions.c	/^decl* makestructdecl(ste* fields){$/;"	f
maketypedecl	functions.c	/^decl* maketypedecl(int type){$/;"	f
makevardecl	functions.c	/^decl* makevardecl(decl* type_decl){$/;"	f
name	subc.h	/^	struct id *name;$/;"	m	struct:ste	typeref:struct:ste::id
name	subc.h	/^      char *name;$/;"	m	struct:id
next	hash.c	/^	struct nlist *next;$/;"	m	struct:nlist	typeref:struct:nlist::nlist	file:
next	subc.h	/^	struct decl* next;$/;"	m	struct:decl	typeref:struct:decl::decl
nlist	hash.c	/^typedef struct nlist {$/;"	s	file:
nlist	hash.c	/^} nlist;$/;"	t	typeref:struct:nlist	file:
null	subc.h	/^decl *null;$/;"	v
num_index	subc.h	/^	int num_index;  \/\/ ARRAY, # of elements$/;"	m	struct:decl
p	open_test/str_op3.c	/^	int *p;$/;"	m	struct:str	file:
pop_scope	functions.c	/^ste* pop_scope(){$/;"	f
prev	subc.h	/^	struct scope_stack *prev; \/\/ for pop operation$/;"	m	struct:scope_stack	typeref:struct:scope_stack::scope_stack
prev	subc.h	/^	struct ste *prev;$/;"	m	struct:ste	typeref:struct:ste::ste
ptrto	subc.h	/^	struct decl *ptrto; \/\/ POINTER, type of the pointer$/;"	m	struct:decl	typeref:struct:decl::decl
push_scope	functions.c	/^void push_scope(){$/;"	f
push_stelist	functions.c	/^void push_stelist(ste* stelist){$/;"	f
q	open_test/str_op3.c	/^		int *q;$/;"	m	struct:str::str_in	file:
raise	functions.c	/^void* raise(char* errormsg){$/;"	f
returnid	subc.h	/^id* returnid;$/;"	v
returntype	subc.h	/^	struct ste *returntype; $/;"	m	struct:decl	typeref:struct:decl::ste
s	open_test/func_op2.c	/^struct st1 s;$/;"	v	typeref:struct:st1
s	open_test/func_op3.c	/^struct st1 s;$/;"	v	typeref:struct:st1
s	open_test/str_op3.c	/^	} s;$/;"	m	struct:str	typeref:struct:str::str_in	file:
s	open_test/str_op3.c	/^struct str1 s;$/;"	v	typeref:struct:str1
s	open_test/str_op4.c	/^	} *s[10];$/;"	m	struct:str1	typeref:struct:str1::str3	file:
s1	open_test/str_op2.c	/^struct str2 s1;$/;"	v	typeref:struct:str2
s2	open_test/str_op2.c	/^struct str3 s2;$/;"	v	typeref:struct:str3
s2	open_test/str_op3.c	/^	struct str_in s2;$/;"	m	struct:str	typeref:struct:str::str_in	file:
s2	open_test/str_op3.c	/^	struct str_in2 s2; \/* error *\/$/;"	m	struct:str	typeref:struct:str::str_in2	file:
s3	open_test/str_op2.c	/^struct str4 s3; \/* error : not declared *\/$/;"	v	typeref:struct:str4
s4	open_test/str_op2.c	/^struct x s4; \/* error : not struct type *\/$/;"	v	typeref:struct:x
sa	open_test/str_op3.c	/^struct str1 sa[10];$/;"	v	typeref:struct:str1
sa	open_test/str_op4.c	/^struct str1 sa[10];$/;"	v	typeref:struct:str1
sa1	open_test/str_op3.c	/^} sa1[10];$/;"	v	typeref:struct:str1
sa1	open_test/str_op4.c	/^} sa1[10];$/;"	v	typeref:struct:str1
scope	subc.h	/^	struct ste **scope; \/\/ scope when VAR declared$/;"	m	struct:decl	typeref:struct:decl::ste
scope_stack	subc.h	/^typedef struct scope_stack{$/;"	s
scope_stack	subc.h	/^} scope_stack;$/;"	t	typeref:struct:scope_stack
setprocdecl	functions.c	/^decl* setprocdecl(decl* func, ste* formals){$/;"	f
sf	open_test/func_op2.c	/^struct st1 sf(int x, int y){$/;"	f
sf	open_test/func_op2.c	/^struct x{int x;} sf(int a, int c){ \/* error *\/$/;"	f
sf	open_test/func_op3.c	/^struct st1 sf(){$/;"	f
sf2	open_test/func_op2.c	/^struct st2{int x; int y;} sf2(int x, int y){$/;"	f
sf2	open_test/func_op3.c	/^struct st2{int x; int y;} sf2(void){$/;"	f
sf2_2	open_test/func_op2.c	/^struct st2{int x;} sf2_2(int a, int c){ \/* error : redecl *\/$/;"	f
sf3	open_test/func_op2.c	/^struct st3 sf3(int x){ \/* error *\/$/;"	f
sf3	open_test/func_op3.c	/^struct st3 sf3(){ \/* error *\/$/;"	f
size	subc.h	/^	int size; \/\/ size in byte$/;"	m	struct:decl
sp	open_test/str_op3.c	/^	struct str_in *sp;$/;"	m	struct:str	typeref:struct:str::str_in	file:
sp	open_test/str_op3.c	/^struct str1 *sp;$/;"	v	typeref:struct:str1
sp3	open_test/str_op3.c	/^} *sp3;$/;"	v	typeref:struct:str3
spa	open_test/str_op3.c	/^struct str1 *spa[10];$/;"	v	typeref:struct:str1
spa	open_test/str_op4.c	/^struct str1 *spa[10];$/;"	v	typeref:struct:str1
spa2	open_test/str_op3.c	/^} *spa2[10];$/;"	v	typeref:struct:str2
spa2	open_test/str_op4.c	/^} *spa2[10];$/;"	v	typeref:struct:str2
spf	open_test/func_op2.c	/^struct st3{int a;} *spf(int x){$/;"	f
spf	open_test/func_op3.c	/^struct st3{int a;} *spf(){ $/;"	f
spf	open_test/func_op3.c	/^struct st3{int b;} spf(){ \/* error *\/$/;"	f
ss	open_test/func_op2.c	/^struct st2 ss; \/* pass *\/$/;"	v	typeref:struct:st2
ss	open_test/func_op3.c	/^struct st2 ss; \/* pass *\/$/;"	v	typeref:struct:st2
sstop	subc.h	/^scope_stack *sstop;$/;"	v
st	open_test/str_op.c	/^	} st;$/;"	m	struct:str2	typeref:struct:str2::str3	file:
st	open_test/str_op2.c	/^		struct str3{} st; \/* error, redec *\/$/;"	m	struct:str4::str_in	typeref:struct:str4::str_in::str3	file:
st	open_test/str_op2.c	/^		} st;$/;"	m	struct:str2::str3	typeref:struct:str2::str3::str_in	file:
st	open_test/str_op2.c	/^	} st;$/;"	m	struct:str2	typeref:struct:str2::str3	file:
st	open_test/str_op2.c	/^	}st;$/;"	m	struct:str4	typeref:struct:str4::str_in	file:
st1	open_test/func_op2.c	/^struct st1{int x; int y;};$/;"	s	file:
st1	open_test/func_op3.c	/^struct st1{int x; int y;};$/;"	s	file:
st2	open_test/func_op2.c	/^struct st2{int x; int y;} sf2(int x, int y){$/;"	s	file:
st2	open_test/func_op2.c	/^struct st2{int x;} sf2_2(int a, int c){ \/* error : redecl *\/$/;"	s	file:
st2	open_test/func_op2.c	/^struct st2{} a; \/* error *\/$/;"	s	file:
st2	open_test/func_op2.c	/^struct st2{}; \/* error *\/$/;"	s	file:
st2	open_test/func_op3.c	/^struct st2{int x; int y;} sf2(void){$/;"	s	file:
st2	open_test/func_op3.c	/^struct st2{} a; \/* error *\/$/;"	s	file:
st2	open_test/func_op3.c	/^struct st2{}; \/* error *\/$/;"	s	file:
st2	open_test/str_op2.c	/^		struct str_in st2;$/;"	m	struct:str2::str3	typeref:struct:str2::str3::str_in	file:
st3	open_test/func_op2.c	/^struct st3{int a;} *spf(int x){$/;"	s	file:
st3	open_test/func_op3.c	/^struct st3{int a;} *spf(){ $/;"	s	file:
st3	open_test/func_op3.c	/^struct st3{int b;} spf(){ \/* error *\/$/;"	s	file:
ste	subc.h	/^typedef struct ste{$/;"	s
ste	subc.h	/^} ste;$/;"	t	typeref:struct:ste
str	open_test/str_op3.c	/^struct str{$/;"	s	file:
str1	open_test/str_op.c	/^struct str1 {$/;"	s	file:
str1	open_test/str_op2.c	/^struct str1 {$/;"	s	file:
str1	open_test/str_op3.c	/^struct str1{$/;"	s	file:
str1	open_test/str_op4.c	/^struct str1{$/;"	s	file:
str2	open_test/str_op.c	/^struct str2 {$/;"	s	file:
str2	open_test/str_op2.c	/^struct str2 {$/;"	s	file:
str2	open_test/str_op3.c	/^struct str2{$/;"	s	file:
str2	open_test/str_op4.c	/^struct str2{$/;"	s	file:
str3	open_test/str_op.c	/^	struct str3 {$/;"	s	struct:str2	file:
str3	open_test/str_op.c	/^struct str3 { \/* error, redeclaration of struct str3 *\/$/;"	s	file:
str3	open_test/str_op2.c	/^		struct str3{} st; \/* error, redec *\/$/;"	s	struct:str4::str_in	file:
str3	open_test/str_op2.c	/^	struct str3 {$/;"	s	struct:str2	file:
str3	open_test/str_op2.c	/^struct str3 { \/* error, redeclaration of struct str3 *\/$/;"	s	file:
str3	open_test/str_op3.c	/^struct str3{$/;"	s	file:
str3	open_test/str_op4.c	/^	struct str3{$/;"	s	struct:str1	file:
str4	open_test/str_op2.c	/^struct str4{$/;"	s	file:
strCompare	hash.c	/^int strCompare(char* x, int length, char* y){$/;"	f
strCompare_no_len	hash.c	/^int strCompare_no_len(char* x, char* y){$/;"	f
strCompare_no_len	test.c	/^int strCompare_no_len(char* x, char* y){$/;"	f
str_in	open_test/str_op2.c	/^		struct str_in {$/;"	s	struct:str2::str3	file:
str_in	open_test/str_op2.c	/^	struct str_in{ \/* error, redec *\/$/;"	s	struct:str4	file:
str_in	open_test/str_op2.c	/^struct str_in{ \/* error, redec *\/$/;"	s	file:
str_in	open_test/str_op3.c	/^	struct str_in{$/;"	s	struct:str	file:
str_in2	open_test/str_op2.c	/^		struct str_in2{$/;"	s	struct:str2::str3	file:
top	subc.h	/^	struct ste *top; \/\/ top of the ste$/;"	m	struct:scope_stack	typeref:struct:scope_stack::ste
type	subc.h	/^	struct decl *type;$/;"	m	struct:decl	typeref:struct:decl::decl
typeclass	subc.h	/^	int typeclass;$/;"	m	struct:decl
voidtype	subc.h	/^decl *voidtype;$/;"	v
x	open_test/func_op2.c	/^int x;$/;"	v
x	open_test/func_op2.c	/^struct st1{int x; int y;};$/;"	m	struct:st1	file:
x	open_test/func_op2.c	/^struct st2{int x; int y;} sf2(int x, int y){$/;"	m	struct:st2	file:
x	open_test/func_op2.c	/^struct st2{int x;} sf2_2(int a, int c){ \/* error : redecl *\/$/;"	m	struct:st2	file:
x	open_test/func_op2.c	/^struct x{int x;} sf(int a, int c){ \/* error *\/$/;"	m	struct:x	file:
x	open_test/func_op2.c	/^struct x{int x;} sf(int a, int c){ \/* error *\/$/;"	s	file:
x	open_test/func_op3.c	/^int x;$/;"	v
x	open_test/func_op3.c	/^struct st1{int x; int y;};$/;"	m	struct:st1	file:
x	open_test/func_op3.c	/^struct st2{int x; int y;} sf2(void){$/;"	m	struct:st2	file:
x	open_test/str_op2.c	/^			int x;$/;"	m	struct:str2::str3::str_in	file:
x	open_test/str_op2.c	/^	int x;$/;"	m	struct:str_in	file:
x	open_test/str_op2.c	/^int x;$/;"	v
x	open_test/str_op3.c	/^	int x;$/;"	m	struct:str	file:
x	open_test/str_op3.c	/^	int x;$/;"	m	struct:str1	file:
x	open_test/str_op3.c	/^	int x;$/;"	m	struct:str2	file:
x	open_test/str_op3.c	/^	int x;$/;"	m	struct:str3	file:
x	open_test/str_op3.c	/^int x;$/;"	v
x	open_test/str_op4.c	/^		int x;$/;"	m	struct:str1::str3	file:
x	open_test/str_op4.c	/^	int x;$/;"	m	struct:str1	file:
x	open_test/str_op4.c	/^	int x;$/;"	m	struct:str2	file:
x	open_test/str_op4.c	/^int x;$/;"	v
x2	open_test/str_op2.c	/^			int x2;$/;"	m	struct:str2::str3::str_in2	file:
y	open_test/func_op2.c	/^struct st1{int x; int y;};$/;"	m	struct:st1	file:
y	open_test/func_op2.c	/^struct st2{int x; int y;} sf2(int x, int y){$/;"	m	struct:st2	file:
y	open_test/func_op3.c	/^struct st1{int x; int y;};$/;"	m	struct:st1	file:
y	open_test/func_op3.c	/^struct st2{int x; int y;} sf2(void){$/;"	m	struct:st2	file:
y	open_test/str_op2.c	/^			int y[10];$/;"	m	struct:str2::str3::str_in	file:
y	open_test/str_op3.c	/^	int y;$/;"	m	struct:str	file:
y	open_test/str_op3.c	/^	int y;$/;"	m	struct:str1	file:
y	open_test/str_op3.c	/^	int y;$/;"	m	struct:str2	file:
y	open_test/str_op3.c	/^	int y;$/;"	m	struct:str3	file:
y	open_test/str_op4.c	/^		int y;$/;"	m	struct:str1::str3	file:
y	open_test/str_op4.c	/^	int y;$/;"	m	struct:str1	file:
y	open_test/str_op4.c	/^	int y;$/;"	m	struct:str2	file:
y2	open_test/str_op2.c	/^			int y2;$/;"	m	struct:str2::str3::str_in2	file:
